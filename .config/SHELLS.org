#+TITLE: Shells
#+AUTHOR: Artem Smaznov
#+STARTUP: overview

* Table of Contents :toc:
- [[#bash][Bash]]
  - [[#start-section][Start Section]]
  - [[#options][Options]]
  - [[#history][History]]
  - [[#exports][Exports]]
  - [[#auto-complete][Auto-complete]]
  - [[#sources][Sources]]
  - [[#end-section][End Section]]
- [[#zsh][ZSH]]
  - [[#options-1][Options]]
  - [[#history-1][History]]
  - [[#exports-1][Exports]]
  - [[#auto-complete-1][Auto-complete]]
  - [[#keys][Keys]]
  - [[#sources-1][Sources]]
  - [[#end-section-1][End Section]]
- [[#fish][Fish]]
  - [[#end-section-2][End Section]]
- [[#aliases][Aliases]]
  - [[#start][Start]]
  - [[#editors][Editors]]
  - [[#listing-directories][Listing directories]]
  - [[#changing-directories][Changing directories]]
  - [[#copy][Copy]]
  - [[#search][Search]]
  - [[#tools][Tools]]
  - [[#system][System]]
  - [[#git][Git]]
  - [[#archives][Archives]]
- [[#starship][Starship]]

* Bash
** Start Section

#+begin_src shell :tangle ~/.bashrc
#!/bin/bash

# If not running interactively, don't do anything
[[ $- != *i* ]] && return

iatest=$(expr index "$-" i)
#+end_src

** Options

#+begin_src shell :tangle ~/.bashrc
# VIM mode - comment this out if you are not comfirtable with vim or kniw what vim is
set -o vi

# Disable the bell
if [[ $iatest > 0 ]]; then bind "set bell-style visible"; fi

shopt -s globstar     # ** to mean reclusive
shopt -s autocd       # auto cd when entering just the path
shopt -s checkwinsize # Check the window size after each command and, if necessary, update the values of LINES and COLUMNS

#+end_src

** History

#+begin_src shell :tangle ~/.bashrc
# Allow ctrl-S for history navigation (with ctrl-R)
stty -ixon

# Causes bash to append to history instead of overwriting it so if you start a new terminal, you have old session history
shopt -s histappend
PROMPT_COMMAND='history -a'

# Expand the history size
export HISTFILESIZE=10000
export HISTSIZE=10000
export HISTFILE=$HOME/.cache/shell_history

# Don't put duplicate lines in the history and do not add lines that start with a space
export HISTCONTROL=erasedups:ignoreboth
#+end_src

** Exports

#+begin_src shell :tangle ~/.bashrc
# Make local bin files usable
export PATH=$PATH:$HOME/.local/bin:$HOME/.local/bin/dmscripts:$HOME/.config/emacs/bin

# Set user folder paths
export GIT_DIRECTORY="$HOME/projects"
export WALL_DIRECTORY="$HOME/Pictures/wallpapers"

# Set the default editor
export EDITOR=vim
export VISUAL=vim

### SET MANPAGER
export MANPAGER='/bin/bash -c "vim -MRn -c \"set buftype=nofile showtabline=0 ft=man ts=8 nomod nolist noma\" -c \"normal L\" -c \"nmap q :qa<CR>\"</dev/tty <(col -b)"'

# Color for manpages in less makes manpages a little easier to read
export LESS_TERMCAP_mb=$'\E[01;31m'
export LESS_TERMCAP_md=$'\E[01;31m'
export LESS_TERMCAP_me=$'\E[0m'
export LESS_TERMCAP_se=$'\E[0m'
export LESS_TERMCAP_so=$'\E[01;44;33m'
export LESS_TERMCAP_ue=$'\E[0m'
export LESS_TERMCAP_us=$'\E[01;32m'
#+end_src

** Auto-complete

#+begin_src shell :tangle ~/.bashrc
# Enable history completion with up and down arrow keys
bind '"\e[A": history-search-backward'
bind '"\e[B": history-search-forward'

# Ignore case on auto-completion
# Note: bind used instead of sticking these in .inputrc
if [[ $iatest > 0 ]]; then bind "set completion-ignore-case on"; fi

# Show auto-completion list automatically, without double tab
# if [[ $iatest > 0 ]]; then bind "set show-all-if-ambiguous On"; fi
#+end_src

** Sources

#+begin_src shell :tangle ~/.bashrc
source_config() {
  [ -f $1 ] && source $1
}

# Primary imports
source_config $HOME/.config/aliasrc
source_config $HOME/.config/bash/wol
source_config $HOME/.config/bash/prompt
source_config $HOME/.config/bash/bashrc

# FZF configs
source_config /usr/share/fzf/key-bindings.bash
source_config /usr/share/fzf/completion.bash
#+end_src

** End Section

#+begin_src shell :tangle ~/.bashrc
# Source the Starship Prompt
if hash starship 2>/dev/null; then
  eval "$(starship init bash)"
fi

# Script to run on terminal launch
if hash neofetch 2>/dev/null; then
  neofetch
fi
#+end_src

* ZSH
** Options

#+begin_src shell :tangle ~/.zshrc
# VIM mode - comment this out if you are not comfirtable with vim or kniw what vim is
bindkey -v

unsetopt beep # Disable the bell

setopt autocd # auto cd when entering just the path
#+end_src

** History

#+begin_src shell :tangle ~/.zshrc
# History
SAVEHIST=10000
HISTSIZE=10000
HISTFILE=$HOME/.cache/shell_history

# Causes zsh to append to history instead of overwriting it so if you start a new terminal, you have old session history
setopt INC_APPEND_HISTORY

# Don't put duplicate lines in the history and do not add lines that start with a space
setopt HIST_IGNORE_ALL_DUPS
setopt HIST_IGNORE_SPACE
#+end_src

** Exports

#+begin_src shell :tangle ~/.zshrc
# Make local bin files usable
path+=($HOME/.local/bin)
path+=($HOME/.local/bin/dmscripts)
path+=($HOME/.config/emacs/bin)

# Set user folder paths
export GIT_DIRECTORY="$HOME/projects"
export WALL_DIRECTORY="$HOME/Pictures/wallpapers"

# Set the default editor
export EDITOR=vim
export VISUAL=vim

### SET MANPAGER
export MANPAGER='/bin/zsh -c "vim -MRn -c \"set buftype=nofile showtabline=0 ft=man ts=8 nomod nolist noma\" -c \"normal L\" -c \"nmap q :qa<CR>\"</dev/tty <(col -b)"'
#+end_src

** Auto-complete

#+begin_src shell :tangle ~/.zshrc
fpath=($HOME/.config/zsh/completion $fpath)
zstyle :compinstall filename "$HOME/.zshrc"

# Autocompletion
autoload -Uz compinit && compinit # Load autocompletion
zstyle ':completion::complete:*' gain-privileges 1 # Enable aliases for Sudo commands
zstyle ':completion:*' menu select
zstyle ':completion:*' rehash true                 # automatically rehash bin files
zstyle ':completion:*' matcher-list '' 'm:{a-zA-Z}={A-Za-z}'

zstyle -e ':completion:*:default' list-colors 'reply=("${PREFIX:+=(#bi)($PREFIX:t)(?)*==02=01}:${(s.:.)LS_COLORS}")' # Color the common prefix

# enable history search
autoload -Uz up-line-or-beginning-search down-line-or-beginning-search
zle -N up-line-or-beginning-search
zle -N down-line-or-beginning-search
#+end_src

** Keys

#+begin_src shell :tangle ~/.zshrc
# create a zkbd compatible hash;
# to add other keys to this hash, see: man 5 terminfo
typeset -g -A key

key[Home]="${terminfo[khome]}"
key[End]="${terminfo[kend]}"
key[Insert]="${terminfo[kich1]}"
key[Backspace]="${terminfo[kbs]}"
key[Delete]="${terminfo[kdch1]}"
key[Up]="${terminfo[kcuu1]}"
key[Down]="${terminfo[kcud1]}"
key[Left]="${terminfo[kcub1]}"
key[Right]="${terminfo[kcuf1]}"
key[PageUp]="${terminfo[kpp]}"
key[PageDown]="${terminfo[knp]}"
key[Shift-Tab]="${terminfo[kcbt]}"
key[Control-Left]="${terminfo[kLFT5]}"
key[Control-Right]="${terminfo[kRIT5]}"

# setup key accordingly
[[ -n "${key[Home]}"          ]] && bindkey -- "${key[Home]}"          beginning-of-line
[[ -n "${key[End]}"           ]] && bindkey -- "${key[End]}"           end-of-line
[[ -n "${key[Backspace]}"     ]] && bindkey -- "${key[Backspace]}"     backward-delete-char
[[ -n "${key[Delete]}"        ]] && bindkey -- "${key[Delete]}"        delete-char
[[ -n "${key[Up]}"            ]] && bindkey -- "${key[Up]}"            up-line-or-beginning-search
[[ -n "${key[Down]}"          ]] && bindkey -- "${key[Down]}"          down-line-or-beginning-search
[[ -n "${key[Left]}"          ]] && bindkey -- "${key[Left]}"          backward-char
[[ -n "${key[Right]}"         ]] && bindkey -- "${key[Right]}"         forward-char
[[ -n "${key[PageUp]}"        ]] && bindkey -- "${key[PageUp]}"        beginning-of-buffer-or-history
[[ -n "${key[PageDown]}"      ]] && bindkey -- "${key[PageDown]}"      end-of-buffer-or-history
[[ -n "${key[Shift-Tab]}"     ]] && bindkey -- "${key[Shift-Tab]}"     reverse-menu-complete
[[ -n "${key[Control-Left]}"  ]] && bindkey -- "${key[Control-Left]}"  backward-word
[[ -n "${key[Control-Right]}" ]] && bindkey -- "${key[Control-Right]}" forward-word

# Bind ctrl + space to accept the current suggestion.
bindkey '^ ' end-of-line

# Bind Alt + . to insert last argument
bindkey '^[.' insert-last-word

# Finally, make sure the terminal is in application mode, when zle is
# active. Only then are the values from $terminfo valid.
if (( ${+terminfo[smkx]} && ${+terminfo[rmkx]} )); then
  autoload -Uz add-zle-hook-widget
  function zle_application_mode_start { echoti smkx }
  function zle_application_mode_stop { echoti rmkx }
  add-zle-hook-widget -Uz zle-line-init zle_application_mode_start
  add-zle-hook-widget -Uz zle-line-finish zle_application_mode_stop
fi
#+end_src

** Sources

#+begin_src shell :tangle ~/.zshrc
source_config() {
  [ -f $1 ] && source $1
}

# Primary imports
source_config $HOME/.config/aliasrc
source_config $HOME/.config/bash/wol
source_config $HOME/.config/zsh/zshrc

# FZF configs
source_config /usr/share/fzf/key-bindings.zsh
source_config /usr/share/fzf/completion.zsh

# Plugins - need to be loaded at the very end
source_config /usr/share/zsh/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
source_config /usr/share/zsh/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh
#+end_src

** End Section

#+begin_src shell :tangle ~/.zshrc
# Source the Starship Prompt
if hash starship 2>/dev/null; then
  eval "$(starship init zsh)"
fi

# Script to run on terminal launch
if hash neofetch 2>/dev/null; then
  neofetch
fi
#+end_src

* Fish
** End Section
#+begin_src conf :tangle ~/.config/fish/config.fish
starship init fish | source
#+end_src

* Aliases
To temporarily bypass an alias, we precede the command with a `\`
e.g. the ls command is aliased, but to use the normal ls command you would type `\ls`

** Start

#+begin_src shell :tangle ~/.config/aliasrc
#!/usr/bin/env bash

# Add an "alert" alias for long running commands.  Use like so:
#   sleep 10; alert
alias alert='notify-send --urgency=low -i "$([ $? = 0 ] && echo terminal || echo error)" "$(history|tail -n1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&|]\s*alert$//'\'')"'

# Enable aliases for Sudo commands
alias sudo='sudo '

alias makepkg='makepkg -si'
#+end_src

** Editors

#+begin_src shell :tangle ~/.config/aliasrc
alias nano='nano -c'
alias snano='sudo nano'
alias svim='sudo vim'
#+end_src

** Listing directories

#+begin_src shell :tangle ~/.config/aliasrc
if hash exa 2>/dev/null; then
    alias exa='exa --icons --group-directories-first'
    alias ls='exa -Fh'                # add file type extensions
    alias la='ls -ah'                 # show hidden files
    alias ll='ls -al'                 # long listing format
else
    alias ls='ls -Fh --color=always'  # add colors and file type extensions
    alias la='ls -Ah'                 # show hidden files
    alias ll='ls -als'                # long listing format
fi
alias llf="\ls -l | egrep -v '^d'" # long list files only
alias lld="\ls -l | egrep '^d'"    # long list directories only
#+end_src

** Changing directories

#+begin_src shell :tangle ~/.config/aliasrc
alias ~='cd ~'
alias cd..='cd ..'
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias .....='cd ../../../..'

# cd back into the previous directory
alias bd='cd "$OLDPWD"'

# Make directories recursively
alias mkdir='mkdir -p'

# Create and go to the directory
mkdirg() {
    mkdir -p $1
    cd $1
}
#+end_src

** Copy
Copy file with a progress bar

#+begin_src shell :tangle ~/.config/aliasrc
cpp() {
    set -e
    strace -q -ewrite cp -- "${1}" "${2}" 2>&1 |
        awk '{
    count += $NF
    if (count % 10 == 0) {
        percent = count / total_size * 100
        printf "%3d%% [", percent
        for (i=0;i<=percent;i++)
            printf "="
            printf ">"
            for (i=percent;i<100;i++)
                printf " "
                printf "]\r"
            }
        }
    END { print "" }' total_size=$(stat -c '%s' "${1}") count=0
}
#+end_src

** Search

#+begin_src shell :tangle ~/.config/aliasrc
# Less
alias less='less -iRNJ --use-color'

# Grep
alias grep='grep --colour=auto'
alias sgrep='grep -R -n -H -C 5 --exclude-dir={.git,.svn,CVS} '

# Search command line history
alias h="history | grep "

# Search files in the current folder
alias f="find . | grep "
alias ff='find . -type f -name'
alias fd='find . -type d -name'

# Count all files (recursively) in the current folder
alias countfiles="for t in files links directories; do echo \`find . -type \${t:0:1} | wc -l\` \$t; done 2> /dev/null"

# Searches for text in all files in the current folder
ftext() {
    # -i case-insensitive
    # -I ignore binary files
    # -H causes filename to be printed
    # -r recursive search
    # -n causes line number to be printed
    # optional: -F treat search term as a literal, not a regular expression
    # optional: -l only print filenames and not the matching lines ex. grep -irl "$1" *
    grep -iIHrn --color=always "$1" . | less -r
}
#+end_src

** Tools

#+begin_src shell :tangle ~/.config/aliasrc
# Start ArchiSteamFarm
if [[ -d ~/ASF ]]; then
    alias asf='~/ASF/ArchiSteamFarm'
fi

# Start Picom
alias startpicom='picom -b --experimental-backends --dbus'

# Update Proton
alias update-proton='$GIT_DIRECTORY/../SystemSoftware/ProtonUpdater/cproton.sh'

# Setup extra password store
alias pay='PASSWORD_STORE_DIR=~/.payment-store pass'
#+end_src

** System
*** Pacman

#+begin_src shell :tangle ~/.config/aliasrc
alias pacman-upgrade='sudo pacman -syu'
alias pacman-mirrors-update='sudo pacman-mirrors --geoip'
alias pacman-orphans-clean='sudo pacman -rs $(pacman -qtdq)'
alias pacman-orphans-fullclean='sudo pacman -rns $(pacman -qtdq)'
# fzf
alias pacman-browse="pacman -Slq | fzf --multi --preview 'pacman -Si {1}' | xargs -ro sudo pacman -S"
alias pacman-list="pacman -Qq | fzf --multi --preview 'pacman -Qi {1}' | xargs -ro sudo pacman -Rcs"
#+end_src

*** Power Control

#+begin_src shell :tangle ~/.config/aliasrc
alias reboot='sudo shutdown -r now'
alias forcereboot='sudo shutdown -r -n now'
alias shutdown='sudo shutdown -P'
alias suspend='systemctl suspend'
#+end_src

*** System Tools

#+begin_src shell :tangle ~/.config/aliasrc
# Alias's to show disk space and space used in a folder
alias diskspace="du -S | sort -n -r |more"
alias folders='du -h --max-depth=1'
alias folderssort='find . -maxdepth 1 -type d -print0 | xargs -0 du -sk | sort -rn'
alias tree='tree -CAhF --dirsfirst'
alias treed='tree -CAFd'
alias mountedinfo='df -hT'

# Audio Outout info
alias aoutput='cat /proc/asound/card2/pcm0p/sub0/hw_params'

# Search running processes
alias p="ps aux | grep "
alias topcpu="/bin/ps -eo pcpu,pid,user,args | sort -k 1 -r | head -10"

# Show all logs in /var/log
alias logs="sudo find /var/log -type f -exec file {} \; | grep 'text' | cut -d' ' -f1 | sed -e's/:$//g' | grep -v '[0-9]$' | xargs tail -f"
#+end_src

*** Networking

#+begin_src shell :tangle ~/.config/aliasrc
# Show used DNS addresses
alias dnsview='cat /etc/resolv.conf'

# Show current network connections to the server
alias ipview="netstat -anpl | grep :80 | awk {'print \$5'} | cut -d\":\" -f1 | sort | uniq -c | sort -n | sed -e 's/^ *//' -e 's/ *\$//'"

# Show open ports
alias openports='netstat -nape --inet'

# SSH
alias extendtolaptop='ssh -YC wifi-laptop-arch x2x -east -to :0.0'
#+end_src

** Git
#+begin_src shell :tangle ~/.config/aliasrc
alias gs="git fetch && git status"
alias gc="git commit"
alias gp="git push"
alias gf="git pull"
alias gd="git diff"
#+end_src

*** Bare Repositories
#+begin_src shell :tangle ~/.config/aliasrc
bare_repos=(
    "dot"
    "private"
)

for repo in "${bare_repos[@]}"; do
    case $repo in
        dot)
            bare_git_dir="$GIT_DIRECTORY/Dotfiles/"
            bare_work_tree="$HOME" ;;
        private)
            bare_git_dir="$GIT_DIRECTORY/private-Dotfiles/"
            bare_work_tree="$HOME" ;;
    esac

    alias g$repo="git --git-dir=$bare_git_dir --work-tree=$bare_work_tree"
    alias gs$repo="g$repo fetch && g$repo status"
    alias gc$repo="g$repo commit"
    alias gp$repo="g$repo push"
    alias gf$repo="g$repo pull"
    alias gd$repo="g$repo diff"
done
#+end_src

*** Pass
#+begin_src shell :tangle ~/.config/aliasrc
alias pgs="pass git status"
alias pgp="pass git push"
alias pgf="pass git pull"
#+end_src

** Archives
Extracts any archive(s) (if unp isn't installed)

#+begin_src shell :tangle ~/.config/aliasrc
ex() {
    for archive in $*; do
        if [ -f $archive ]; then
            case $archive in
                ,*.tar.bz2) tar xvjf $archive ;;
                ,*.tar.gz) tar xvzf $archive ;;
                ,*.bz2) bunzip2 $archive ;;
                ,*.rar) rar x $archive ;;
                ,*.gz) gunzip $archive ;;
                ,*.tar) tar xvf $archive ;;
                ,*.tbz2) tar xvjf $archive ;;
                ,*.tgz) tar xvzf $archive ;;
                ,*.zip) unzip $archive ;;
                ,*.Z) uncompress $archive ;;
                ,*.7z) 7z x $archive ;;
                ,*) echo "don't know how to extract '$archive'..." ;;
            esac
        else
            echo "'$archive' is not a valid file!"
        fi
    done
}
#+end_src

* Starship
Inserts a blank line between shell prompts
#+begin_src toml :tangle ~/.config/starship.toml
add_newline = true
#+end_src

Replace the =❯= symbol in the prompt with =➜=
#+begin_src toml :tangle ~/.config/starship.toml
[character]
success_symbol = "[➜](bold green)"
#+end_src

#+begin_src toml :tangle ~/.config/starship.toml
# [hostname]
# ssh_only = false

# [username]
# show_always = true

# [directory]
# truncation_length = 3
# truncate_to_repo = true
#+end_src
